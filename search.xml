<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用Django Signal 实现对模块的解耦]]></title>
    <url>%2F2019%2F05%2F05%2Fdjango-signal-usage%2F</url>
    <content type="text"><![CDATA[最近负责开发一个自动发现主机信息的应用。应用中数据流向复杂，处理逻辑冗余堆积。项目技术栈选择的是Django + Vuejs。前端使用 Webpack打包，模块化管理，主要是展示数据。后端涉及的模块多、处理规则多、数据表多，每次涉及之前功能修改时，都消耗大量时间进行code review。让我才意识到，在复杂应用中解耦模块非常重要。下面是一些调研和实践。 1. 观察者模式 2. Django Signal 2.1 简单的例子 2.2 从源码理解Django Signal处理逻辑 3. 信号解耦、异步任务 1. 观察者模式在实践中，我主要使用的是 Django Signal，实现对模块的解耦。Django Signal 是 Django 对观察者模式的实现和应用。因此，有必要先了解一下观察者模式。 观察者模式是软件设计模式的一种。通常，大家会使用等式：发布 + 订阅 = 观察者模式。来表达对观察者模式的理解。实际上，这个等式并不完全正确。 发布订阅模式与观察者模式区别： 发布订阅模式的通信依赖于消息队列（RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMq等）属于异步，观察者模式通常是同步的。 发布订阅模式松散耦合，发布者和订阅者甚至所属不同应用；观察者模式所属一个应用。在实现上，观察者模式，需要维护一个订阅列表。当状态发生改变时，自动通知列表中的全部对象。 2. Django SignalSignal 是 Django 框架中提供的一个信号分发器。发送器发送信号，通知一系列的接收器，从而触发接收器执行一些操作。 需要注意的是，Django 信号是同步的。如果滥用，会影响到 Django 的处理效率。 下面我会以 Django1.8.3为例，从一个使用案例出发，再到源码，介绍 Django 中 Signal 的实现方式。 2.1 简单的例子这里有一个小需求：在Model表执行save后，触发一些执行逻辑。 加载Signal myApp/init.py 123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-default_app_config = &apos;myApp.apps.MyAppConfig&apos;myApp/apps.py# -*- coding: utf-8 -*-from django.apps import AppConfigclass MyAppConfig(AppConfig): name = &apos;myApp&apos; def ready(self): import myApp.signals.handlers绑定信号处理函数myApp/signals/handlers.py# -*- coding: utf-8 -*-from django.dispatch import receiverfrom django.db.models.signals import post_savefrom myApp.models import MyModel@receiver(post_save, sender=MyModel, dispatch_uid=&quot;mymodel_post_save&quot;)def my_model_handler(sender, **kwargs): # 这里写 MyModel 执行 save 后的逻辑 pass 2.2 从源码理解Django Signal处理逻辑上面的例子，使用了极少量的代码，就享受到了 Django 提供的信号处理机制所带来的便利。但是，如果仅仅停留在使用，你可能无法对 Django Signal有更深入的了解。下面，从源码来看看 Django Signal 的处理逻辑。 声明信号Django 内置了大量 Model 相关的信号，可以直接使用。上面例子使用的信号 post_save ，就是 ModelSignal 类的一个实例，而 ModelSignal 又继承自 Signal 类。 1234567891011django/db/models/signal.pyfrom django.dispatch import Signalclass ModelSignal(Signal): def connect(self, receiver, sender=None, weak=True, dispatch_uid=None): super(ModelSignal, self).connect( receiver, sender=sender, weak=weak, dispatch_uid=dispatch_uid )post_save = ModelSignal(providing_args=[&quot;instance&quot;, &quot;raw&quot;, &quot;created&quot;, &quot;using&quot;, &quot;update_fields&quot;], use_caching=True) 注册信号处理函数Django 提供的 receiver 函数是一个装饰器，被修饰的函数作为参数注册到接收器对象列表。 123456789101112131415161718192021django/dispatch/__init__.pyfrom django.dispatch.dispatcher import Signal, receiverdjango/dispatch/dispatcher.pydef receiver(signal, **kwargs): def _decorator(func): if isinstance(signal, (list, tuple)): for s in signal: s.connect(func, **kwargs) else: signal.connect(func, **kwargs) return func return _decoratordjango/dispatch/dispatcher.pyclass Signal(object): def __init__(self, providing_args=None, use_caching=False): self.receivers = [] def connect(self, receiver, sender=None, weak=True, dispatch_uid=None): self.receivers.append((lookup_key, receiver)) 发送信号在 save 完成之后，Django 会主动发出 post_save 信号；如果是自定义信号，那么需要自行触发。。 123456789django/db/models/base.pyclass Model(six.with_metaclass(ModelBase)): # 触发 Model 相关的信号 def save_base(self, raw=False, force_insert=False, force_update=False, using=None, update_fields=None): # Signal that the save is complete signals.post_save.send(sender=origin, instance=self, created=(not updated), update_fields=update_fields, raw=raw, using=using) 处理信号，实际上就是依次调用接受器列表中的函数。 12345678910django/dispatch/dispatcher.pyclass Signal(object): def send(self, sender, **named): responses = [] for receiver in self._live_receivers(sender): response = receiver(signal=self, sender=sender, **named) responses.append((receiver, response)) return responses 3. 信号解耦、异步任务在学习了观察者模式，了解 Django Signal 之后，就基本掌握了 Django 模块解耦的基础知识。接着，需要进一步明确模块之间的耦合机制，制定项目约定，就可以利落地实践了。 梳理一下请求的处理链路： 请求经过接入层、中间件处理之后，由 URL 分发器匹配到合适的处理模块，最终某个模块负责返回响应。各个模块连接数据库、消息队列、对象存储保存状态。 每个模块包含四部分： AppLogic，模块的应用逻辑 Signal，模块内置的信号 SignalHandle，模块关注的信号处理句柄 CeleryTasks，模块的异步任务 模块与模块之前完全通过信号耦合： 由于 Django Signal 是同步处理机制，为了支持异步处理，可以结合 Celery 和 RabbitMQ 进行实践。 下面是一个信号处理异步逻辑的例子： 1234567891011121314151617181920212223242526myApp/tasks.py# -*- coding: utf-8 -*-from celery import task@task(ignore_result=True)def my_task(instance): passmyApp/signals/handlers.py# -*- coding: utf-8 -*-from django.dispatch import receiverfrom django.db.models.signals import post_savefrom myApp.models import MyModelfrom myApp.tasks import my_task@receiver(post_save, sender=MyModel, dispatch_uid=&quot;mymodel_post_save&quot;)def my_model_handler(sender, **kwargs): instance = kwargs[&apos;instance&apos;] # 异步 my_task.apply_async(args=[instance]) # 同步 pass]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitLab-CI持续集成实践]]></title>
    <url>%2F2019%2F05%2F05%2Fgitlab-ci-practice%2F</url>
    <content type="text"><![CDATA[持续集成是一种软件开发实践，即团队开发成员经常集成它们的工作，通过每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽早地发现集成错误。gitlab一般用Gitlab-CI，而github一般用jenkins，主要功能是在你提交或merge代码到仓库后，自动执行一些你定义好的命令， 比如安装依赖、单元测试、pep8检查、甚至还可以自动部署到生成环境。前段时间自己给当前做的项目加上了gitlab-ci,实现的主要功能是提交代码后自动检测安装依赖有没有问题，单元测试能不能通过， pep 8 规范检查是否合格，有一项不合格就会在提交的分支或merge后面有个显目的红叉， 全通过的话则是一个赏心悦目的绿色对勾。 GitLab简单原理图 安装和配置Runner pipeline 配置 pep 8 GitLab简单原理图 安装和配置Runner首先， gitlab ci 需要单独部署在一台服务器上来运行， 对应的程序是GitLab Runner,在ubuntu和centos上安装都是先根据一个shell脚本安装各种依赖， 然后再执行安装程序。123456# For Debian/Ubuntu $ curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.deb.sh | sudo bash $ sudo apt-get install gitlab-ci-multi-runner # For CentOS $ curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.rpm.sh | sudo bash $ sudo yum install gitlab-ci-multi-runner 为了能够让GitLab Runner 能够连接到我们的项目上需要注册操作：sudo gitlab-runner register然后根据提示输入配置信息（这些信息可以在项目的gitlab网站的CI/CD 配置里找到， 需要master权限）1234567891011121314151617181920Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com ) https://gitlab.com //项目gitlab的根域名， 一般公司都会部署自己内部使用的gitlab Please enter the gitlab-ci token for this runner xxx // gitlab token, 每个项目都不一样 Please enter the gitlab-ci description for this runner [hostame] my-runner // 项目描述， 起个名称 Please enter the gitlab-ci tags for this runner (comma separated): my-tag,another-tag // 给该 Runner 指派 tags, 稍后也可以在 GitLab&apos;s UI 修改, 这里也可以直接回车， 使用默认值 Whether to run untagged jobs [true/false]: [false]: true // 选择 Runner 是否接收未指定 tags 的任务（默认值：false）， 稍后可以在 GitLab&apos;s UI 修改 Whether to lock Runner to current project [true/false]: [true]: false // 该runner是否只能运行当前指定项目（根据token来判断的），默认值：true： Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell: shell // 选择runner的类型， 这里用shell就好 配置完成， sudo gitlab-runner list 可以查看当前runner的状态。 pipeline 配置GitLab Runner 启动成功后接下来就是在你的项目里配置gitlab ci要干哪些事情了， 在项目的根目录新建一个.gitlab-ci.yml 文件，在里边配置代码commit后gitlab ci要干的事情。一个简单的示例如下：12345678910111213141516# 定义 stages stages: - build - test # 定义 job job1: stage: test script: - echo &quot;I am job1&quot; - echo &quot;I am in test stage&quot; # 定义 job job2: stage: build script: - echo &quot;I am job2&quot; - echo &quot;I am in build stage&quot; 执行顺序如下： stages里的stage按顺序执行， 如果有一个stage执行失败， 结束， 不再往下执行。 执行每个stage时，stage里的job并行执行， 所有job都执行成功该stage才算成功， 有一个失败的话该stage执行失败， 结束。 此外，还有连个非常有用的选项——before_script 和 after_script, 分别对应着每个job执行前后要运行的额外代码。更多的配置选项可以看gitlab ci的官方文档 pep 8当多人参与一个项目时， 统一代码规范就很重要。 python一般用的是pep 8， 用flake 8 可以很方便做到。 安装 pip install flake8 pep8-naming 在项目根目录下新建一个.flake8配置文件 配置文件内容大概如下（不要出现中文， 后面的注释是为了便于读者理解额外添加的）：12345678910111213141516171819202122[flake8] ignore = W292 W391 E126 W291 N805 // 忽略的格式类型 exclude = // 忽略的文件、文件夹 *migrations*, # python related *.pyc, .git, __pycache__, *.conf, *.md, config* *settings* manage.py gold/vulpo/* max-line-length=125 // 单行最大字数 max-complexity=16 // 复杂度上限 format=pylint show_source = True statistics = True count = True 当然， 记得在.gitlab-ci.yml 中添加一个执行pep 8 检查的job：12345pep8_test: stage: pep8 script: - flake8 gold # allow_failure: true // 有追求的程序员当然不会允许pep 8 检查不通过]]></content>
      <categories>
        <category>CI/CD</category>
      </categories>
      <tags>
        <tag>CI/CD</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
</search>
